#summary Details of how XML-RPC methods should declare their signatures and help sections
#labels Phase-Design,Featured

= Note =

*This page is not applicable to the trunk or the 0.1 release*.

To use the functionality described on this page you need to use the introspection-dev branch, available [https://code.launchpad.net/~codedragon/django-xmlrpc/introspection-dev here].

= Introduction =

Method introspection in django_xmlrpc is an issue because the XML-RPC dispatcher that it uses, SimpleXMLRPCServer.SimpleXMLRPCDispatcher, doesn't support the system.methodSignature() method.

In order to get around this, django_xmlrpc subclasses SimpleXMLRPCDispatcher and looks for a signature property on each XML-RPC-registered method when system.methodSignature() is called on that method.

The method signature can be added using the decorator `@xmlrpc_func`, which can be found in the `decorators` module of django_xmlrpc.

= Adding a Signature to a Function =

You can add an XML-RPC signature to a method using the `xmlrpc_func` decorator:

{{{
from django_xmlrpc.decorators import xmlrpc_func

@xmlrpc_func(returns='string', args=['int', 'string',])
def hanging_on_the_wall(number, item):
    return "There are %i %ss hanging on the wall" % (number, item)
}}}

== What happens if I don't specify signatures? ==

XML-RPC signatures are not essential when registering a function with django_xmlrpc. Although they can be of great use to XML-RPC clients looking to use the services you provide, you may choose not to use them.

In this case, django_xmlrpc will use the `getargspec()` method provided by the `inspect` built-in Python module to find out how many parameters your method takes. Since the most interoperable type in these circumstances is a string, the client will be told that all these parameters should be strings and that the method returns a string. For example, django_xmlrpc will give the following a default signature of `[string, string, string, string]`, which in this case is fine:

{{{
def my_xmlrpc_method(spam, eggs, ham):
    return spam + " " + eggs + " " + ham
}}}


There is a chance that this could lead to some nasty surprises for clients; please bear it in mind if you chose not to add XML-RPC signatures to your methods. For example, not specifying a signature here could lead to problems:

{{{
def my_other_xmlrpc_method(his_shoe, his_gourd):
    return his_shoe * his_gourd
}}}
